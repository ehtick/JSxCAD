// import { Empty } from './Empty.js';
// import { Group } from './Group.js';
// import { alignment } from './alignment.js';
// import { by } from './by.js';
import { eachItem } from './tagged/eachItem.js';
// import { getLayouts } from './tagged/getLayouts.js';
// import { getLeafs } from './tagged/getLeafs.js';
// import { getList } from './get.js';
// import { measureBoundingBox } from './measureBoundingBox.js';
// import { pack as packOp } from './pack.js';
// import { taggedLayout } from './tagged/taggedLayout.js';

/*
const MIN = 0;
const MAX = 1;
const X = 0;
const Y = 1;

const buildLayout = ({
  layer,
  pageWidth,
  pageLength,
  margin,
  center = false,
}) => {
  const size = [pageWidth, pageLength];
  let layout = taggedLayout({ size, margin }, layer, Empty());
  if (center) {
    layout = by(layout, alignment(layout));
  }
  return layout;
};

export const Page = (
  geometries,
  { pack, center, a4, individual },
  { size, pageMargin = 5, itemMargin = 1, itemsPerPage = Infinity } = {}
) => {
  if (a4) {
    size = [210, 297];
  }

  if (individual) {
    pack = true;
    itemsPerPage = 1;
  }

  const margin = itemMargin;
  const layers = [];
  for (const geometry of geometries) {
    for (const leaf of getLeafs(geometry)) {
      layers.push(leaf);
    }
  }
  if (!pack && size) {
    const layer = Group(layers);
    const [width, height] = size;
    const packSize = [
      [-width / 2, -height / 2, 0],
      [width / 2, height / 2, 0],
    ];
    const pageWidth =
      Math.max(
        1,
        Math.abs(packSize[MAX][X] * 2),
        Math.abs(packSize[MIN][X] * 2)
      ) +
      pageMargin * 2;
    const pageLength =
      Math.max(
        1,
        Math.abs(packSize[MAX][Y] * 2),
        Math.abs(packSize[MIN][Y] * 2)
      ) +
      pageMargin * 2;
    return buildLayout({
      layer,
      pageWidth,
      pageLength,
      margin,
      center,
    });
  } else if (!pack && !size) {
    const layer = Group(layers);
    const packSize = measureBoundingBox(layer);
    if (packSize === undefined) {
      return Empty();
    }
    const pageWidth =
      Math.max(
        1,
        Math.abs(packSize[MAX][X] * 2),
        Math.abs(packSize[MIN][X] * 2)
      ) +
      pageMargin * 2;
    const pageLength =
      Math.max(
        1,
        Math.abs(packSize[MAX][Y] * 2),
        Math.abs(packSize[MIN][Y] * 2)
      ) +
      pageMargin * 2;
    if (isFinite(pageWidth) && isFinite(pageLength)) {
      return buildLayout({
        layer,
        pageWidth,
        pageLength,
        margin,
        center,
      });
    } else {
      return buildLayout({
        layer,
        pageWidth: 0,
        pageLength: 0,
        margin,
        center,
      });
    }
  } else if (pack && size) {
    // Content fits to page size.
    const packSize = [];
    const content = packOp(
      Group(layers),
      (min, max) => {
        packSize[MIN] = min;
        packSize[MAX] = max;
      },
      {
        size,
        pageMargin,
        itemMargin,
        perLayout: itemsPerPage,
      }
    );
    if (packSize.length === 0) {
      throw Error('Packing failed');
    }
    const pageWidth = Math.max(1, packSize[MAX][X] - packSize[MIN][X]);
    const pageLength = Math.max(1, packSize[MAX][Y] - packSize[MIN][Y]);
    if (isFinite(pageWidth) && isFinite(pageLength)) {
      const plans = [];
      for (const layer of getList(content, ['pack:layout'])) {
        plans.push(
          buildLayout({
            layer,
            pageWidth,
            pageLength,
            margin,
            center,
          })
        );
      }
      return Group(plans);
    } else {
      const layer = Group(layers);
      return buildLayout({
        layer,
        pageWidth: 0,
        pageLength: 0,
        margin,
        center,
      });
    }
  } else if (pack && !size) {
    const packSize = [];
    // Page fits to content size.
    const contents = packOp(
      Group(layers),
      (min, max) => {
        packSize[MIN] = min;
        packSize[MAX] = max;
      },
      {
        pageMargin,
        itemMargin,
        perLayout: itemsPerPage,
      }
    );
    if (packSize.length === 0) {
      throw Error('Packing failed');
    }
    // FIX: Using content.size() loses the margin, which is a problem for repacking.
    // Probably page plans should be generated by pack and count toward the size.
    const pageWidth = packSize[MAX][X] - packSize[MIN][X];
    const pageLength = packSize[MAX][Y] - packSize[MIN][Y];
    if (isFinite(pageWidth) && isFinite(pageLength)) {
      const plans = [];
      for (const layer of getList(contents, ['pack:layout'])) {
        const layout = buildLayout({
          layer,
          packSize,
          pageWidth,
          pageLength,
          margin,
          center,
        });
        plans.push(layout);
      }
      return Group(plans);
    } else {
      const layer = Group(layers);
      return buildLayout({
        layer,
        pageWidth: 0,
        pageLength: 0,
        margin,
        center,
      });
    }
  }
};

export const page = (
  geometry,
  { pack, center, a4, individual },
  { size, pageMargin = 5, itemMargin = 1, itemsPerPage = Infinity } = {}
) =>
  Page(
    [geometry],
    { pack, center, a4, individual },
    { size, pageMargin, itemMargin, itemsPerPage }
  );
*/

export const ensurePages = (geometry, depth = 0) => {
  const sheets = [];
  eachItem(geometry, (item) => {
    if (item.type === 'item' && item.tags.includes('pack:sheet')) {
      sheets.push(item);
    }
  });
  return sheets;
};
