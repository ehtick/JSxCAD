import {
  disjoint,
  isNotTypeGhost,
  linearize,
  makeAbsolute,
  measureBoundingBox,
  scale,
  section,
  transformCoordinate,
  transformingCoordinates,
  translate,
} from '@jsxcad/geometry';

import { toRgbColorFromTags } from '@jsxcad/algorithm-color';

const equals = (a, b) => a && b && a[0] === b[0] && a[1] === b[1];

const X = 0;
const Y = 1;

export const toSvg = async (
  baseGeometry,
  { padding = 0, definitions } = {}
) => {
  const sectioned = section(await baseGeometry, [{ type: 'points', tags: [] }]);
  const disjointed = disjoint(sectioned, {});
  // svg reverses the Y axis.
  const scaled = scale(disjointed, [1, -1, 1]);
  const [baseMin] = measureBoundingBox(scaled);
  const translated = translate(disjointed, [-baseMin[X], -baseMin[Y], 0]);
  const geometry = makeAbsolute(translated);
  const [min, max] = measureBoundingBox(geometry);
  const width = max[X] - min[X];
  const height = max[Y] - min[Y];
  const viewBox = `${min[X].toFixed(5)} ${min[Y].toFixed(5)} ${width.toFixed(
    5
  )} ${height.toFixed(5)}`;
  const svg = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<!-- Generated by jsxcad -->`,
    `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">`,
    `<svg baseProfile="tiny" height="${height.toFixed(
      5
    )}mm" width="${width.toFixed(
      5
    )}mm" viewBox="${viewBox}" version="1.1" stroke="black" stroke-width=".1" fill="none" xmlns="http://www.w3.org/2000/svg">`,
  ];

  for (const { matrix, tags, polygonsWithHoles } of linearize(
    geometry,
    (geometry) =>
      geometry.type === 'polygonsWithHoles' && isNotTypeGhost(geometry)
  )) {
    for (const polygonWithHoles of polygonsWithHoles) {
      const { points, holes } = polygonWithHoles;
      const color = toRgbColorFromTags(tags, definitions);
      const d = [];
      points.forEach(
        transformingCoordinates(matrix, (point, index) =>
          d.push(
            `${index === 0 ? 'M' : 'L'}${point[0].toFixed(
              5
            )} ${point[1].toFixed(5)}`
          )
        )
      );
      d.push('z');
      for (const { points } of holes) {
        points.forEach(
          transformingCoordinates(matrix, (point, index) =>
            d.push(
              `${index === 0 ? 'M' : 'L'}${point[0].toFixed(
                5
              )} ${point[1].toFixed(5)}`
            )
          )
        );
        d.push('z');
      }
      if (d.length > 0) {
        svg.push(
          `<path fill="${color}" stroke="${color}" d="${d.join(' ')}"/>`
        );
      }
    }
  }

  for (const g of linearize(
    geometry,
    (geometry) => geometry.type === 'segments' && isNotTypeGhost(geometry)
  )) {
    const { matrix, tags, segments } = g;
    const color = toRgbColorFromTags(tags, definitions);
    let d = [];
    let first;
    let last;
    for (let [start, end] of segments) {
      const [startX, startY] = transformCoordinate(start, matrix);
      const [endX, endY] = transformCoordinate(end, matrix);
      if (!equals(start, last)) {
        d.push(`M ${startX.toFixed(5)} ${startY.toFixed(5)}`);
      }
      d.push(`L ${endX.toFixed(5)} ${endY.toFixed(5)}`);
      if (!first) {
        first = start;
      }
      last = end;
    }
    if (equals(first, last)) {
      d.pop();
      d.push('z');
    }
    if (d.length > 0) {
      svg.push(`<path stroke="${color}" d="${d.join(' ')}"/>`);
    }
  }

  svg.push('</svg>');
  const output = svg.join('\n');
  return new TextEncoder('utf8').encode(`${output}\n`);
};
