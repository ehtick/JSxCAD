const laneWidth = control('lane width', 3.5, 'input');

const mm = 160 / 1000;

const tileWidth = 64 * mm;

md`Each tile is ${(tileWidth * 1000) / 160}mm`;

const curve = await Line(laneWidth)
  .x(tileWidth / 2)
  .seq({ by: 1 / 32, to: 1 / 4 }, rz, ChainHull)
  .x(tileWidth / -2)
  .y(tileWidth / 2)
  .color('black')
  .tag('road_surface');

const tightCurve = await Line(laneWidth)
  .x(tileWidth / 4)
  .seq({ by: 1 / 32, to: 1 / 4 }, rz, ChainHull)
  .x(tileWidth / -4)
  .y(tileWidth / 2)
  .color('black')
  .tag('road_surface');

const doubleLaneCurve = await Line(laneWidth * 2)
  .x(tileWidth / 2)
  .seq({ by: 1 / 32, to: 1 / 4 }, rz, ChainHull)
  .x(tileWidth / -2)
  .y(tileWidth / 2)
  .color('black')
  .tag('road_surface');

const doubleLaneCurveMarked = await doubleLaneCurve.fitTo(
  Box(0.2, 0.4)
    .x(tileWidth / 2)
    .color('white')
    .tag('road_marking')
    .seq({ from: 1 / 64, by: 1 / 32, to: 1 / 4 }, rz)
    .x(tileWidth / -2)
    .y(tileWidth / 2)
);

const tile = await Box(tileWidth)
  .color('white')
  .tag('pavement')
  .and(outline().color('black'));

const lane = await Box(laneWidth, [laneWidth / -2, tileWidth / 2])
  .color('black')
  .tag('road_surface');

const doubleLane = await lane
  .x(laneWidth / -2, laneWidth / 2)
  .color('black')
  .tag('road_surface');

const doubleLaneMarked = await doubleLane.fitTo(
  Box(0.2, 0.4)
    .color('white')
    .tag('road_marking')
    .seq({ from: laneWidth / -2 + 0.6, upto: tileWidth / 2 - 0.1, by: 0.8 }, y)
);

const roadEndTile = await tile.fitTo(lane.rz(0 / 4)).as('road end');

const doubleLaneRoadEndTile = await tile
  .fitTo(doubleLaneMarked.rz(0 / 4))
  .as('double lane road end');

const curvedRoadTile = await tile.fitTo(curve).as('curved road');

const doubleLaneCurvedRoadTile = await tile
  .fitTo(doubleLaneCurveMarked)
  .as('2 lane curved road');

const roadCornerTile = await tile.fitTo(lane.rz(0 / 4, 1 / 4)).as('road corner');

const threeWayIntersectionTile = await tile
  .fitTo(lane.rz(0 / 4, 1 / 4, 2 / 4))
  .as('3 way intersection');

const curvedThreeWayIntersectionTile = await tile
  .fitTo(curve.rz(0 / 4, 1 / 4), lane.rz(1 / 4, 3 / 4))
  .as('curved 3 way intersection');

const fourWayIntersectionTile = await tile
  .fitTo(lane.rz(0 / 4, 1 / 4, 2 / 4, 3 / 4))
  .as('4 way intersection');

const curvedFourWayIntersectionTile = await tile
  .fitTo(
    curve.rz(0 / 4, 1 / 4, 2 / 4, 3 / 4),
    lane.rz(0 / 4, 1 / 4, 2 / 4, 3 / 4)
  )
  .as('curved 4 way intersection');

const doubleLaneCurvedFourWayIntersectionTile = await tile
  .fitTo(
    doubleLaneCurve.rz(0 / 4, 1 / 4, 2 / 4, 3 / 4),
    doubleLane.rz(0 / 4, 1 / 4, 2 / 4, 3 / 4)
  )
  .as('2 lane curved 4 way intersection');

const roadTile = await tile.fitTo(lane.rz(0 / 4, 2 / 4)).as('road');

const doubleLaneRoadTile = await tile
  .fitTo(doubleLaneMarked.rz(0 / 4, 2 / 4))
  .as('double lane road');

const doubleLaneCurvedThreeWayIntersectionTile = await tile
  .fitTo(doubleLaneCurve.rz(0 / 4, 1 / 4).join(doubleLane.rz(1 / 4, 3 / 4)))
  .fitTo(
    Box(0.2, 0.4)
      .color('white')
      .seq(
        { from: laneWidth / -2 + 0.6, upto: tileWidth / 2 - 0.1, by: 0.8 },
        y
      )
      .rz(1 / 4, 3 / 4)
  )
  .as('2 lane 3 way curved intersection');

const doubleToSingleLaneCurvedThreeWayIntersectionTile = await tile
  .fitTo(
    curve
      .y(tileWidth / -2)
      .sy(0.5)
      .y(tileWidth / 2)
      .sx(1, -1)
      .color('black'),
    doubleLaneMarked.rz(1 / 4, 3 / 4)
  )
  .as('2 to 1 lane 3 way curved intersection');

const doubleToSingleLaneCurvedFourWayIntersectionTile = await tile
  .fitTo(
    curve
      .y(tileWidth / -2)
      .sy(0.5)
      .y(tileWidth / 2)
      .sx(1, -1)
      .sy(1, -1)
      .color('black'),
    doubleLane.rz(1 / 4, 3 / 4)
  )
  .as('2 to 1 lane 4 way curved intersection');

const extrudeTile = () => async (shape) => {
  console.log(`QQ/extrudeTile/shape: ${JSON.stringify(shape)}`);
  const result = await shape
    .on(getAll('user:road_marking'), ez(1.2 * mm))
    .on(getAll('user:road_surface'), ez(1 * mm))
    .on(getAll('user:pavement'), ez(2 * mm));
  console.log(`QQ/extrudeTile/result: ${JSON.stringify(result)}`);
  return result;
}

await Group(roadTile, curvedRoadTile)
  .op(extrudeTile())
  .stl('3yd tiles', page('individual'));

await Group(
  roadTile.copy(1),
  doubleLaneRoadTile.copy(1),
  roadEndTile.copy(1),
  doubleLaneRoadEndTile.copy(1),
  curvedRoadTile.copy(1),
  doubleLaneCurvedRoadTile.copy(1),
  curvedThreeWayIntersectionTile.copy(1),
  curvedFourWayIntersectionTile.copy(1),
  doubleLaneCurvedFourWayIntersectionTile.copy(1),
  doubleLaneCurvedThreeWayIntersectionTile.copy(1),
  doubleToSingleLaneCurvedThreeWayIntersectionTile.copy(1),
  doubleToSingleLaneCurvedFourWayIntersectionTile.copy(1)
)
  .scale(1000 / 160)
  .clean()
  .pdf('2d road tile', page('a4', 'pack'))
  .stl('3d road tile', op(extrudeTile()).page('individual'));
